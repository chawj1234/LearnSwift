
```
둘의 관계는 계층적이다. 먼저 아키텍처라는 큰 그림을 그리고, 그 안에 세부적인 문제들을 해결하기 위해 적절한 디자인 패턴을 활용하는 순서로 개발이 진행된다. 
즉, 하나의 아키텍처 패턴은 여러 디자인 패턴의 조합으로 구체화될 수 있다.
```
## 코드 아키텍처 = 집의 전체 설계도
아키텍처는 앱의 전체적인 **뼈대와 구조**를 결정한다. 데이터, UI, 비즈니스 로직 같은 큰 단위들이 서로 어떻게 관계를 맺고 소통할지에 대한 거시적인 규칙
즉, 시스템 전체의 미래를 내다보는 전략적 사고 훈련

### MVC
_"Model(데이터) - View(화면) - Controller(중재자)"_
**구조와 흐름**
1. 사용자가 View에 입력
2. Controller가 입력을 받아서 처리
3. 필요하다면 Controller가 Model의 테이터를 업데이트
4. Model의 데이터가 변경되면 Controller가 이를 감지하고 View를 갱신
5. View가 사용자에게 변경된 화면 보여줌

**장점**
1. 구조가 단순하고 직관적이어서 이해하기 쉽다.
2. UIKit 프레임워크가 이 패턴이라 자연스럽게 접한다.

**단점**
1. 프로젝트가 커지면 너무 많은 코드(View 로직, 데이터 처리, 네트워킹)를 담당하게 되어 뚱뚱해지는 문제 발생 -> 코드 재사용성, 테스트 용이성 떨어짐

### MVVM
#### Model: 애플리케이션의 데이터와 핵심 비즈니스 로직(데이터를 조작, 가공)을 전부 포괄하는 개념
##### 구성 요소
1. **도메인 객체:** 애플리케이션의 핵심 개념을 나타낸다. Ex) 데이터를 담는 구조체, 객체와 관련된 비즈니스 로직
2. **데이터 접근 계층:** 데이터베이스, 네트워크 API 등 실제 데이터 소스와 통신하는 역할
3. **유효성 검사 로직**: 데이터의 무결성을 보장하기 위한 유효성 검사 규칙들이 포함될 수 있다.
##### 다른 계층과의 관계
- **View**와 독립적: View에 대해 직접적으로 알지 못하고 종속되지 않는다.
- **ViewModel**과의 상호작용: Model의 데이터를 가져와서 View가 표시하기 적절한 형태로 가공하고, View의 사용자 입력을 받아 Model에 반영한다.
#### View: 사용자 인터페이스를 담당한다.
##### 역할과 책임
- 정보 표시: ViewModel로부터 전달받은 데이터를 UI로 표현한다.
- 사용자 입력 처리: 입력을 감지하고, 이를 ViewModel에게 전달한다.
- ViewModel과의 데이터 바인딩
- 수동적인 역할: "어떻게 보여줄 것인가"에만 집중하고, "무엇을 할 것인가"는 ViewModel에 위임한다.
- 최소한의 UI 로직: 애니메이션, UI 전환, 키보드 관련 처리(입력, 특수 키) 등 순수하게 UI 표현과 관련된 로직은 뷰 내부에 포함될 수 있다.
##### 다른 계층과의 관계
- **ViewModel**과의 긴밀한 관계: ViewModel의 데이터 표시, ViewModel에게 사용자 입력 전달한다. 하지만 View는 ViewModel이 제공하는 것에 의존해야한다.
- **Model**과 독립적: 데이터 관련 요청이나 업데이트는 ViewModel을 통해 이루어져서 서로 분리되어있다.
#### ViewModel: View와 Model 사이의 중재자
##### 역할과 책임
- View를 위한 데이터 준비: Model로부터 데이터를 받아와 View가 직접 표시할 수 있는 형태로 가공한다. Ex) Model에서 `date` 객체를 받으면 ViewModel에서 이를 `YYYY-MM-DD` 형식의 문자열로 변환하여 뷰에 제공합니다.
- View의 상태 관리: View의 현재 상태(로딩 중 여뷰, 에러 메시지 표시 여부, 버튼 활성화 여부등)를 관리한다
- 사용자 입력 처리: View에서 발생한 입력을 받아 해당 비즈니스 로직을 모델에 요청합니다.
- 커맨드, 액션 노출: 
	\*커맨드: View에서 일어난 행동에 대해 ViewModel에게 **이런 일(액션)을 해줘** 지시하는 명령
	\*액션: 사용자의 상호작용으로 인해 ViewModel이 수행해야 할 특정 기능 또는 동작
- View와 Model 사이의 분리: 각 계층의 변경이 다른 계층에 미치는 영향을 최소화한다.
- UI 로직 추상화: View가 직접 수행해야 할 복잡한 UI 관련 로직을 ViewModel에서 처리하여 View를 더욱 수동적으로 만든다.
##### 다른 계층과의 관계
- **View:** ViewModel은 View에 대해 알지 못하는 것이 이상적이다. 대신 View는 ViewModel의 인터페이스(즉, 뷰모델이 외부에 공개하는 속성이나 커맨드)에 바인딩된다. ViewModel은 View의 라이프사이클에 독립적이다.
- **Model**: ViewModel은 Model에 대한 의존성을 가진다. 모델의 데이터를 요청하고, 모델의 비즈니스 로직을 호출한다.
\*단방향 또는 양방향 바인딩
- 단방향: ViewModel의 속성이 변경되면 View가 자동으로 업데이트되는 것
- 양방향: View에서 사용자 입력이 발생했을 때 입력이 ViewModel의 속성에 반영되는 것


MVVM은 MVC의 뚱뚱한 컨트롤러 문제를 해결하기 위해 등장했다. 
Controller의 역할 중 **View를 위한 데이터 가공 및 상태 관리를 ViewModel이 전담**하도록 분리한 구조
**구조와 흐름**
1. 사용자가 View에 입력
2. View는 입력을 ViewModel에게 전달
3. ViewModel이 비즈니스 로직을 처리하고 Model 업데이트 
4. Model이 변경되면 ViewModel의 데이터도 변경된다.
5. 데이터 바인딩을 통해 ViewModel의 변경사항이 View에 자동으로 반영된다.

**장점**
1. Controller의 부담을 줄여 코드가 훨씬 깔끔해진다.
2. ViewModel은 UI 프레임워크(UIKit/SwiftUI)에 의존하지 않으므로 로직을 테스트하기 매우 쉽습니다.
3. View와 비즈니스 로직이 분리되어 재사용성이 높아진다.

**단점**
1. 데이터 바인딩을 위한 추가적인 학습(Combine, RxSwift)이 필요할 수 있다.

----
## 디자인 패턴 = 구체적인 건축 공법
아키텍처라는 큰 틀 안에서 발생하는 반복적이고 구체적인 문제들을 해결하기 위한 미시적인 설계
즉, 코드의 품질과 재사용성을 높이는 전술적 사고이다.

크게 **생성, 구조, 행동** 세 가지로 나뉜다.
### 생성 패턴
1. **싱글톤**: 앱 전체에서 단 하나의 인스턴스만 생성되도록 보장하는 패턴
	1. 장점: 메모리 절약, 전역적 접근 쉬워 데이터 공유 편리
	2. 단점: 남용시 다른 객체와 강하게 결합되어 테스트 어렵고, 의존성을 숨김
2. **팩토리 메서드:** 객체를 생성하는 코드를 별도의 '팩토리' 메서드로 캡슐화하여, 서브 클래스에서 어떤 클래스의 인스턴스를 만들지를 결정한다.
3. **빌더**: 생성자의 매개변수가 많거나, 객체 생성 과정이 여러 단계로 복잡할 때, 생성 과정과 표현 방법을 분리한다. 이를 통해 동일한 생성 절차를 가지고도 다양한 속성을 가진 객체를 만들 수 있고 가독성을 크게 향상시킨다.
### 구조 패턴
1. **어뎁터**: 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작할 수 있도록 변환기 역할을 하는 클래스
	1. 장점: 기존 코드를 수정하지 않도도 새로운 클래스와 통합할 수 있어 유연성이 높음
2. **데코레이터:** 상속을 사용하지 않고, 객체를 다른 객체로 감싸는 방식을 통해 동적으로 새로운 책임이나 기능을 추가한다.
3. **프록시**: 특정 객체에 대한 접근을 제어하기 위해 그 객체 대신하는 '대리자(Proxy)' 객체를 제공하는 패턴. 실제 객체에 대한 접근을 관리하며, 추가적인 로직(접근 제어, 로딩 지연, 로깅 등)을 수행할 수 있다.
### 행동 패턴
1. **스트레티지:** 여러 알고리즘을 각각의 클래스로 캡슐화하고, 이들을 동적으로 교체할 수 있도록 만드는 패턴. '무엇을 할 것인가'와 '어떻게 할 것인가'를 분리하여, 클라이언트 코드의 변경 없이 알고리즘을 쉽게 추가하거나 변경할 수 있다.
2. **델리게이트**: 하나의 객체가 처리해야 할 일의 일부를 다른 객체에게 위임(Delegate)하는 패턴. 이때 해야 할 일의 목록은 프로토콜로 정의
	1. 장점: 객체 간의 결합도를 낮추면서 유연한 상호작용 가능
3. **옵저버**: 한 객체(Subject)의 상태가 변하면, 그 객체를 구독(Observe)하고 있는 여러 다른 객체들(Observers)에게 자동으로 변경 사항을 알림. 1:N 관계의 소통 방식
	1. 장점: 서로 모르는 객체들 간에도 데이터 교환이 가능하여 결합도가 매우 낮다.
4. **커맨드**: 요청 사항을 객체로 캡슐화하는 패턴. 이를 통해 요청을 보내는 객체(Invoker)와 요청을 실제로 처리하는 객체(Receiver)를 분리할 수 있다.
