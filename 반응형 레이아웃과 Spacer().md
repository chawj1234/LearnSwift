# 레이아웃 협상 과정
SwiftUI는 **UI를 구성하는 모든 요소**를 "**뷰**"라고 정의한다.
이는 부모 뷰와 자식 뷰 사이에서 크기를 결정하는 3단계 프로세스이다.
다음과 같이 진행된다.
1. 부모의 제안
	부모 뷰는 자식 뷰에게 사용 가능한 공간의 크기를 **제안**한다. 이 제안은 `너는 최대 300x500의 공간을 사용할 수 있어`와 같은 형태의 ProposedViewSize 구조체로 전달된다.
	\***ProposedViewSize 구조체**: `width`,`height`속성을 가지며 각 속성은 다음과 같은 의미를 가진다
		`ProposedViewSize(width: .infinity, height: 200)`
		1. 구체적인 숫자 값: 부모가 자식에게 정확히 이 크기만큼만 사용해라.
		2. .infinity: 부모가 자식에게 네가 원하는 만큼 최대한 확장해라.
		3. nil: 자식 뷰가 자신의 콘텐츠에 맞춰 자연스럽게 크기를 결정해라.
2. 자식의 결정
	자식 뷰는 부모로부터 받은 제안을 바탕으로 자신의 고유한 특성 즉, **콘텐츠**(뷰 내부에 있는 실제 데이터)와 **수식어**(뷰의 모양, 동작, 레이아웃 특성을 변경하는 메서드) 에 따라 크기를 '스스로 결정'한다. 
3. 부모의 배치
	부모 뷰는 자식 뷰가 보고한 크기를 바탕으로, 자신의 좌표공간 내에 자식 뷰를 최종적으로 배치한다. 이때 alignment 설정이 사용된다.

이 협상 과정에서 가장 중요한 원칙은 자식 뷰가 자신의 크기를 최종적으로 결정한다는 것이다. 즉, 부모의 크기 제안을 받고 자신의 콘텐츠에 따라 최종 크기를 결정한다.
이러한 협상 메커니즘을 이해하면 '왜 내 프레임이 동작하지 않지'라고 묻는 대신, '부모는 어떤 크기를 제안했는가?' '자식은 그 제안에 대해 어떤 크기로 응답했는가?'라는 질문을 던져야 한다.

## 탐욕적인 뷰 VS 콘텐츠 순응적인 뷰
SwiftUI의 모든 뷰는 레이아웃 협상 과정에서 크기를 결정하는 방식에 따라 두 가지 유형으로 나눈다.
### 1. 탐욕적인 뷰
자신의 이상적인 크기를 무한대로 보고하여 부모로부터 제안받은 가능한 모든 공간을 채우려고 시도한다. **Spacer, Color, Rectangle과 같은 도형, 그리고 GeometryReader가 있다.** 
### 2. 콘텐츠 순응적인 뷰
자신의 콘텐츠 크기를 계산하여 이를 표시하는 데 필요한 최소한의 공간만을 차지한다. **.resizable() 수식어가 적용되지 않은 Image나 Text 뷰가 대표적인 예이다.**

### 이 두 유형의 뷰가 스택(VStack, HStack) 내에서 함께 사용될 때
시스템은 먼저 모든 콘텐츠 순응적인 뷰들의 공간 요구사항을 만족시킨다. 그 후 남은 모든 공간이 탐욕적인 뷰들에게 배분된다.


# Spacer
자신이 차지할 수 있는 최대 크기를 요구하는 탐욕적인 뷰이며, 포함된 스택 레이아웃의 주축을 따라 확장되거나 스택에 포함되지 않은 경우 양 축을 따라 확장된다.

여기서 중요한 상호작용이 있습니다. 스택 컨테이너는 기본적으로 콘텐츠 순응적인 특성을 가진다. 하지만 스택 내부에 Spacer가 포함되는 순간, 스택 자체의 성격이 변한다. 자신의 부모 뷰가 허용하는 최대 크기까지 확장하려는 탐욕적인 컨테이너로 동작한다.
**즉, Spacer를 추가하는 행위는 단순히 빈 공간을 넣는 것이 아니라, 그 부모 컨테이너의 레이아웃 동작 방식까지 변화시킨다.**

## 스택 내에서의 활용법
#### 콘텐츠 밀어내기
- **HStack**에서는 Spacer가 남는 수평 공간을 모두 차지하여 다른 뷰들을 오른쪽, 왼쪽 끝으로 정렬한다.
- **VStack**에서는 Spacer가 남는 수직 공간을 모두 차지하여 다른 뷰들을 윗쪽, 아래쪽 끝으로 정렬한다.
#### 콘텐츠 중앙 정렬
- 특정 뷰 양쪽에 Spacer를 배치하면 해당 뷰를 중앙에 위치시킬 수 있다.
#### 균등 분배
- 여러 뷰 사이에 여러 개의 Spacer를 배치하면, Spacer들이 남은 공간을 균등하게 나누어 가진다.


# 간격 및 크기 조정
### 1. Spacer VS padding(): 유연한 공간 VS 고정된 여백
- **Spacer**는 주변 환경(화면 크기, 다른 뷰의 크기등)에 따라 크기가 변하는 유연한 공간을 만든다.
- **padding()**은 뷰에 적용되는 **수식어**로 콘텐츠 주변에 고정된 크기의 여백을 추가한다.
### 2. Spacer VS .frame(maxWidth:.infinity)
- **Spacer**는 레이아웃을 뷰들의 조합으로 생각합니다. "두 개의 뷰가 있고, 그 사이에 유연하게 늘어나는 빈 공간 뷰를 넣고 싶다"는 의도를 표현한다. 
	이 방식은 코드가 깊게 중첩되는 "피라미드 오브 둠(Pyramid of Doom)" 구조를 만들기 쉽습니다. 뷰 계층이 복잡해지면 코드의 가독성이 떨어지고, 레이아웃 구조를 한눈에 파악하기 어려워 유지보수가 힘들어집니다.
- **.frame(maxWidth:.infinity)** 는 레이아웃을 뷰의 속성으로 생각한다. "하나의 뷰가 있고, 그 뷰의 프레임(또는 터치 가능 영역)을 사용 가능한 공간 전체로 확장하고 싶다"는 의도를 표현한다.
	.frame **수식어**의 alignment 파라미터를 함께 사용하면, **확장된 프레임 내**에서 **콘텐츠**를 원하는 위치로 정렬할 수 있다.
### 3. Spacer VS layoutPriority(): 암시적 제어 VS 명시적 제어
- **Spacer**는 공간 배분을 위한 암시적이고 무딘 도구이다.
- **layoutPriority()** 는 여러 뷰가 제한된 공간을 두고 경쟁할 때 우선 순위를 정하는 명시적이고 정교한 도구이다. 기본적으로 모든 뷰는 layoutPriority가 0이다. 특정 뷰에 더 높은 값을 부여하면 레이아웃 시스템은 해당 뷰의 이상적인 크기를 다른 뷰들보다 먼저 확보하도록 공간을 배분한다.



# 고급 반응형 및 동적 레이아웃
### 1. GeometryReader
자식 뷰에게 **GeometryProxy**라는 값을 제공하는 컨테이너 뷰로 이를 통해 부모 뷰의 크기와 좌표 공간에 대한 정보를 얻을 수 있다. 예를 들어 화면 너비의 80%를 차지하는 카드를 만들고 싶다면
```swift
GeometryReader { geometry in
    RoundedRectangle(cornerRadius: 10)
       .frame(width: geometry.size.width * 0.8)
       .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
}
```
