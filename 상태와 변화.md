Swift는 선언형 패러다임 즉, 애플리케이션의 특정 'state'에 대해 UI가 어떻게 보여야 하는지 선언한다. 이를 통해 UI는 state의 변화에 반응하여 자동으로 업데이트된다. 
이로 인해 개발자의 역할은 UI 컴포넌트를 직접 조작하는 것에서 UI를 결정하는 state 자체를 관리하는 것으로 전환된다. UI를 구성하기 전에, 그 UI를 구동한 데이터, 즉 state를 명확하게 정의해야 한다.

# $UI = f(State)$
SwiftUI의 핵심 원칙은 "데이터가 UI를 주도한다"는 개념으로 요약할 수 있다. 

이를 $UI = f(State)$라는 수식으로 나타낼 수 있다.
$State$: 애플리케이션의 모든 데이터
$f$: View의 body 프로퍼티는 상태를 UI로 변환하는 순수 함수 $f$의 역할
$UI$: 그 결과로 렌더링되는 사용자 인터페이스

SwiftUI의 `View`는 화면에 표시되는 실제 UI 요소가 아니라 특정 시점의 UI를 설명하는 가볍고 일시적인 청사진에 불과하다. `View` [[Protocol]]을 준수하는 struct의 `body` 프로퍼티는 연산 프로퍼티로서, SwiftUI FrameWork가 현재 상태에 기반한 UI 설명을 얻기 위해 언제든지 호출할 수 있다.

\**연산 프로퍼티*: 값을 직접 저장하지 않고(저장 프로퍼티), 다른 프로퍼티의 값을 기반으로 계산하여 반환하는 프로퍼티
\**SwiftUI FrameWork가 현재 상태에 기반한 UI 설명을 얻기 위해 언제든지 호출할 수 있다*: 
1. State 변화에 대한 반응성
	1. SwiftUI는 $UI = f(State)$라는 원칙을 따른다. 따라서 `@State`, `@StateObject`, `@ObservedObject`등으로 관리되는 **State**가 변경될때마다. 해당 상태에 영향을 받는 `View`의 `body` 프로퍼티를 즉시 재호출한다. 이 과정은 SwiftUI FrameWork가 내부적으로 변경을 감지하고 자동으로 수행한다.
2. 효율적 UI 업데이트
	1. `body`프로퍼티가 호출될 때마다 `View`는 새로운 UI 청사진(화면에 그려질 UI 요소들의 계층구조)을 생성한다.
	2. SwiftUI 렌더링 엔진은 이전 `body`호출의 UI 청사진과 새로운 UI 청사진을 비교한다.
	3. 비교를 통해 실제로 변경된 부분만 식별하고 그 부분만 효율적으로 UI 업데이트함으로 효율과 성능을 챙긴다.
3. `View`는 일시적인 청사진
	1. SwiftUI의 `View`는 값 타입인 stuct이다. 따라서 `View`인스턴스는 생성되고 파괴되는 비용이 매우 저렴하다.
	2. 따라서 SwiftUI는 상태가 변경될 때마다 해당  `View`인스턴스를 통째로 다시 생성하는 것을 주저하지 않는다.

SwiftUI의  `View`의 State를 struct내의 일반적인 var 프로퍼티로 선언한다면,  `View`가 다시 생성될 때마다 var 프로퍼티는 초기화 될 것이다. 즉, 저장된 프로퍼티(State)들이 `View`와 수명을 같이하게 되는 것이다.
이를 해결하기 위해서`@State`, `@StateObject`, `@EnvironmentObject`와 같은 **프로퍼티 래퍼(Property Wrapper)** 를 제공하고 이 프로퍼티 래퍼들은 `View`인스턴스의 외부, SwiftUI 프레임워크가 내부적으로 관리하는 별도의 공간에 저장되어야 한다.

# SwiftUI에서의 struct와 class
## 1. struct(대표적 값 타입)
값 타입의 핵심 특징은 인스턴스가 변수에 할당되거나 함수에 저장될 때 데이터의 복사본이 생성된다는 것(pass-by-value)이다. 이는 각 인스턴스가 완전히 독립적임을 보장한다. 또한 다중 스레드 환경(여러 스레드에서 동시에 데이터에 접근)에서 데이터 오염의 위험 없이 안전하게 코드를 작성하게 하고 복잡한 메모리 관리 문제(순환 참조)로부터 자유롭다.

## 2. class(대표적 참조 타입)
참조 타입의 핵심 특징은 객체 인스턴스(class의 인스턴스)가 변수에 할당되거나 함수에 전달될 때 데이터가 저장된 메모리 위치를 가리키는 참조(주소값)만 복사된다. 결과적으로 여러 변수가 하나의 인스턴스를 가리키게 되고 하나의 데이터를 공유한다. 이로 인해 더 이상 아무도 객체 인스턴스를 참조하지 않을 때 객체를 메모리에서 해제하기 위한 메모리 관리 메커니즘([[ARC]])이 필요하다.


# SwiftUI가  `View`에 struct를 선호하는 이유
## 1. 성능
일반적으로 class보다 가볍고 stack 메모리에 할당되는 경우가 많아 생성과 파괴가 매우 빠르다. 덕분에 부담 없이  `View` 계층 전체를 다시 계산하고 생성할 수 있다. 이는 SwiftUI의 반응성을 유지하는 핵심 요소이다.
## 2. 예측 가능성
struct의 
**불변성**(한 번 생성된 데이터의 상태를 변경할 수 없다는 속성)
**값 의미론**(원본 데이터의 복사본이 생성되어 전달되는 방식)
`View`는 상태를 스스로 유지하는 복잡한 객체가 아니라, 특정 시점의 UI를 설명하는 단순하고 상태 없는 값이다. 따라서 외부의 state에 따라 UI를 묘사할 뿐, 스스로 상태를 유지하지 않는다.
## 3. 상속X
struct는 상속을 지원하지 않는다. 이는 더 유연하고 모듈화된 재사용 가능한 `View` 컴포넌트를 만드는 데 도움이 된다.

---
### Swift의 struct - class 비교 분석

| 특징               | struct (값 타입)                           | class (참조 타입)                               | SwiftUI에서의 함의                                                            |
| ---------------- | --------------------------------------- | ------------------------------------------- | ------------------------------------------------------------------------ |
| 타입               | 값 타입 (Value Type)                       | 참조 타입 (Reference Type)                      | 뷰는 가볍고 일회용으로 취급되며, 데이터 모델은 공유가 필요할 때 클래스로 만듭니다.                          |
| 메모리 할당           | 주로 스택(Stack)                            | 항상 힙(Heap)                                  | 뷰의 생성 및 파괴가 매우 빠르고 효율적입니다.                                               |
| 전달/할당 방식         | 데이터 전체가 복사됨 (Pass-by-value)             | 참조(메모리 주소)만 복사됨 (Pass-by-reference)         | 뷰의 상태는 격리되어 예측 가능하며, 공유 데이터는 여러 뷰에서 동일한 인스턴스를 바라봅니다.                     |
| 상속               | 지원하지 않음                                 | 단일 상속 지원                                    | 상속 대신 구성을 통해 뷰를 조립하여 더 유연하고 모듈화된 UI를 만듭니다.                               |
| 초기화              | 멤버와이즈 초기화(Memberwise Initializer) 자동 제공 | 직접 초기화 구문(init)을 구현해야 함                     | 뷰와 간단한 데이터 모델을 간결하게 생성할 수 있습니다.                                          |
| 정체성 비교           | 동등성 비교 (==, Equatable 프로토콜 채택 시)        | 동일성 비교 (=\==) 및 동등성 비교 (==)                 | 뷰는 내용이 같으면 같은 것으로 취급될 수 있지만, 데이터 모델 객체는 고유한 실체로 존재해야 할 때 클래스를 사용합니다.     |
| 메모리 관리           | ARC 불필요 (스코프 벗어나면 자동 해제)                | 자동 참조 계수(ARC)로 관리                           | 순환 참조와 같은 복잡한 메모리 관리 문제에서 뷰는 자유롭습니다.                                     |
| 주요 SwiftUI 사용 사례 | 모든 View 정의, 간단한 로컬 데이터 모델               | 여러 뷰에서 공유되는 복잡한 데이터 모델(ViewModel), 전역 상태 객체 | SwiftUI의 기본 구성 요소는 struct이며, 복잡하고 공유된 상태는 class가 담당하는 명확한 역할 분담이 이루어집니다. |


# @State와 @Binding
## @State
@State는 단일 뷰 내에서 지역적이고 비공개적인 데이터의 '진실의 원천'을 선언하기 위해 사용되는 프로퍼티 래퍼이다. @State 프로퍼티는 해당 뷰 내부에서 소유하고 관리하는 것임을 private으로 선언하는 것이 권장사항이다.
\*진실의 원천: 애플리케이션 내의 특정 데이터가 오직 **한 곳**에서만 **정의**되고 **관리**되어야 한다는 소프트웨어 디자인 원칙이다.

@State로 선언된 프로퍼티의 값이 변경되면, SwiftUI는 이 변화를 자동으로 감지하고 해당 상태에 의존하는 뷰를 무효화하여 body를 다시 그리도록 한다.

### SwiftUI가 @State를 보존하는 방법
@State 어트리뷰터를 붙이면, 해당 프로퍼티는 실제로는 State<Value>라는 제네릭 구조체의 인스턴스가 된다. 
중요한 점은, SwiftUI가 프로퍼티의 저장 공간을 뷰 struct 인스턴스의 **외부**, 즉 프레임워크가 관리하는 특별한 영속적 메모리 영역에 할당한다는 것이다. 이로 인해서 상태 값은 뷰의 잦은 재생성에도 불구하고 값을 유지할 수 있다.
@State 프로퍼티 래퍼는 컴파일 시점에 여러 접근자를 자동으로 생성한다.
- wrappedValue: 프로퍼티 이름(예: count)으로 접근하며, 실제 저장된 값(Int)을 반환합니다.
```swift
struct CounterView: View {
    @State private var count: Int = 0 // 뷰가 소유하는 지역 상태

    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1 // 상태 변경 -> 뷰 자동 업데이트
            }
        }
    }
}
```
- projectedValue: $ 접두사(예: $name)로 접근하며, Binding<Value> 타입의 값을 반환한다. 양방향 바인딩의 핵심
```swift
struct UserInputView: View {
    @State private var name: String = "Guest"

    var body: some View {
        VStack {
            TextField("Enter your name", text: $name) // $name은 Binding<String>을 전달
               .textFieldStyle(.roundedBorder)
               .padding()
            Text("Hello, \(name)!")
        }
    }
}
```
- ~~Property Wrapper Instance: _ 접두사(예: _count)로 접근하며, State<Value> 구조체 인스턴스 자체에 접근합니다. 잘 사용하지 않는다.~~

## 유의 사항
- 항상 초기값을 제공하라: @State 프로퍼티는 선언 시점에 반드시 기본값으로 초기화되어야 한다.
- 항상 `private`으로 선언해라: 상태가 뷰의 내부 구현 사항임을 명확히 하고 외부 접근을 차단한다.
- 지역 상태에만 사용해라: 해당 뷰와 직계 자식 뷰에만 국한된 상태에 사용해야한다. 여러 뷰 계층에 걸쳐 공유도어야 하는 데이터는 `ObservableObject` 프로토콜을 채택한 클래스와 `@ObservedObject` 또는 `@EnvironmentObject`를 사용하는 것이 적합합니다.

## @Binding
@Binding은 다른 뷰가 소유한 '진실의 원천'(주로 부모 뷰의 @State 프로퍼티)에 대한 양방향 연결을 생성한다. 참조와 같이 동작하여 값을 읽고 쓸 수 있는 통로를 제공한다.

## @State를 사용할 때와 진화해야 할 때
### @State는 다음과 같은 경우에 가장 적합한 도구이다.
- 데이터가 단순한 값 타입일 때
- 상태가 특정 뷰에 의해 소유되고, 해당 뷰의 생명 주기를 벗어나 유지될 필요가 없을 때
- 상태가 뷰 계층 구조에서 멀리 전파될 필요 없이, 해당 뷰와 직계 자식 뷰에서만 사용될 때
그러나 상태가 다음과 같은 특성을 갖게 되면 @State의 한계를 넘어서기 때문에 [[ObservableObject]]로 진화해야한다.
- 상태가 복잡한 데이터 구조를 가질 때
- 상태가 여러 비인접 뷰들 간에 공유되어야 할 때
- 상태와 관련된 비즈니스 로직(예: 네트워크 요청, 데이터 베이스 접근, 복잡한 계산)이 필요한 때

